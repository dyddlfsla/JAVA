package chapter.seven.chapter_07_32;

public class Chapter07_32 {

  /** ◆ 추상 메서드 (abstract method)
   *
   * 메서드는 선언부와 구현부(몸통)로 구성되어 있다고 했다. 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상 메서드다.
   * 즉, 설계만 해놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드인 것이다.
   *
   * 메서드를 이와 같이 미완성 상태로 남겨 놓은 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 클래스에서는
   * 선언부만 작성하고, 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성되었는지 알려주고, 실제 내용은 상속받는 클래스에서 구현되도록
   * 비워 두는 것이다. 그래서 추상 클래스를 상속 받는 자손 클래스는 조상의 추상 메서드를 상황에 맞게 적절히 구현해주어야 한다.
   * 추상 메서드 역시 키워드 'abstract' 를 앞에 붙여주고, 추상 메서드는 구현부가 없으므로 괄호{} 대신 문장의 끝을 알리는 ';' 을 적어준다.
   *
   * ---------------------------------------------------------------------------
   * 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다.
   * abstract 리턴타입 메서드이름();
   * ---------------------------------------------------------------------------
   *
   * 추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야 한다. 만일 조상으로부터
   * 상속받는 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.
   *
   * 생각해보면, 실제 작업내용인 구현부가 없는 메서드가 무슨 의미가 있을까 싶지만 메서드를 작성할 때 실제 작업내용인 구현부보다 더 중요한 부분이
   * 선언부이다.
   *
   * 메서드를 사용하는 쪽에서는 메서드가 실제로 어떻게 구현되어있는지 몰라도 메서드의 이름과 매개변수, 리턴타입, 즉 선언부만 알고 있으면 되므로
   * 내용이 없을지라도 추상메서드를 사용하는 코드를 작성하는 것이 가능하며, 실제 자손클래스에 구현된 완성된 메서드가 호출되도록 할 수 있다.
다  *
   * */

}

abstract class Player {

  abstract void play(int pos); // 추상메서드. 메서드의 선언부까지만 만들고 ; 를 붙인다.
  abstract void stop(); // 추상메서드.
}

class AudioPlayer extends Player {

  @Override
  void play(int pos) {
    /* 부모로부터 상속받은 추상메서드 play()를 구현한다. */
  }

  @Override
  void stop() {
    /* 부모로부터 상속받은 추상메서드 stop() 를 구현한다. */
  }

  /* 상속받은 모든 추상메서드를 구현함 */
}

abstract class AbstractPlayer extends Player {

  @Override
  void play(int pos) {
    /* 부모로부터 상속받은 추상메서드 play() 를 구현한다.*/
  }

  /* 상속받은 모든 추상메서드를 구현하지 않음.
  * 모든 추상메서드를 구현하지 못한다면 해당 클래스 역시 추상클래스가 되어야 한다.
  * */
}
