package chapter.three;

public class Chapter03_08 {

  /** ◆ 자동 형변환
   *
   * 서로 다른 타입 간의 대입이나 연산을 할 때, 먼저 형변환으로 타입을 일치시키는 것이 원칙이다. 하지만 경우에 따라 형변환을 생략할 수 있다.
   * 형변환을 생략하는 경우, 해당 컴파일러가 생략된 형변환을 자동적으로 추가해준다.
   *
   *  float f = 1234; // float f = (float)1234; 1234가 int 타입이므로 원래는 (float)를 앞에 붙여주어야 한다. 하지만 생략할 수 있다.
   *
   * 위의 식에서 좌변은 float 타입이고 우변은 int 타입이므로 이 대입 연산이 수행되려면 먼저 타입을 일치시키는 형변환이 필요하다.
   * 하지만 저장될 값이 변수의 타입이 가진 용량보다 작다면 별 다른 형변환 코드 작성 없이 연산 수행이 가능하다.
   *
   * 그러나 반대로, 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에도 형변환을 생략한다면 에러가 발생한다.
   *
   *   byte b = 1000; // 에러. byte 의 범위  -126 ~ 127을 벗어난 값의 대입
   *
   * 그러나 다음과 같이 명시적으로 형변환을 해주는 경우에는 에러를 발생시키지 않는다.
   *
   *  byte b = (byte)1000; // OK. 그러나 형변환을 해준다고 하더라도 결국 작은 범위에 큰 값을 저장하게 되므로 값의 손실이 발생하게 된다.
   *                          b에는 값 -24가 저장된다.
   *
   *
   * 결론적으로, 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환이된다.
   *
   *  byte → short → int → long → float → double
   .  char ↗︎
   *
   * 화살표 방향으로의 변환, 즉 왼쪽에서 오른쪽으로의 변환은 형변환 연산자를 사용하지 않아도 자동 형변환이 되며, 그 반대 방향으로의 변환은
   * 반드시 형변환 연산자를 써야 한다.
   *
   *
   * */

}
