package chapter.three;

public class 연습문제 {

  /** ◆ 3-1. 다음 중 형변환을 생략할 수 있는 것은?
   * sol:
   * ① → ✖︎ int 타입이 byte타입보다 큰 자료형이므로 명시적 형변환이 필요하다.
   * ② → ✖︎ char 타입이 byte보다 큰 자료형이긴 하지만 범위가 다르므로 명시적 형변환이 필요하다.
   * ③ → ✖︎ char 타입과 short 타입은 2byte로 크기는 같지만 범위가 다르기 때문에 형변환이 필요하다.
   * ④ → ✔︎ float 타입이 long 타입보다 크므로 자동 형변환 된다.
   * ⑤ → ✔︎'A'의 유니코드 값은 int 타입보다 작으므로 자동 형변환 된다.
   *
   * 3-2. 다음의 연산결과를 적으시오.
   *
   *  int x = 2;
   *  int y = 5;
   *  char c = 'A'; //'A'의 문자코드는 65
   *
   * sol:
   *  ① → 비트 연산자
   *  ② → true
   *  ③ → y = y + (10 - x++); // 후위형이므로 x의 값이 먼저 참조된 후에 1만큼 증가한다.
   *         = y + (8);
   *         = 5 + 8
   *         = 13
   *  ④ → x += 2;
   *         = x + 2; //위에서 x가 1만큼 증가하였으므로 x는 3이다.
   *         = 3 + 2;
   *         = 5
   *  ⑤ → false
   *  ⑥ → 2
   *  ⑦ → 5
   *  ⑧ → 66
   *  ⑨ → System.out.println(++c); → B 출력
   *       여기서 중요한 것은 증감연산자는 이항 연산자와 달리 타입을 일치시키는 자동 형변환을 하지 않는다는 것이다.
   *       따라서 println()메서드는 변수 c를 숫자(int)로 출력하지 않으며 문자로 출력한다. 즉, 변수 c에
   *       ++로 인해 1만큼 증가한 67이 저장되고 이 67이 숫자로 출력되는 것이 아니라 문자로 출력되는 것이다.
   *       66은 문자코드에 따라 'B'에 해당하므로 'B'가 출력된다.
   *  ⑩ → B
   *  ⑪ → C
   *
   * 3-3. 백의 자리 이하를 버리는 코드이다. 알맞은 코드를 넣으시오.
   *  sol:
   *  Math.round(num / 100 * 100);
   *  int타입으로 나눗셈을 하게 되면 몫만 남고 나머지는 버려지므로 이를 활용하면 된다.
   *
   * 3-4. 사과를 담는데 필요한 바구니 수를 구하는 코드이다. 알맞은 코드를 넣으시오.
   *   int numOfApples = 123;
   *   int sizeOfBucket = 10;
   *
   * sol:
   *  int numOfBucket = numOfApples / sizeOfBucket + (numOfApples%sizeOfBucket > 0 ? 1 : 0);
   *
   * 3-5. 변수 num의 값에 따라 '양수', '음수', '0'을 출력한다. 알맞은 코드를 넣으시오.
   *  int num = 10;
   *
   * sol: num > 0 ? "양수" : (num == 0 ? "0" : "음수");
   *
   * 3-6. 화씨를 섭씨로 변환하는 코드이다. 알맞은 코드를 넣으시오.
   *  int fahrenheit = 100;
   *
   *
   * */
}
