package chapter.eleven._14;

public class Chapter11_14 {

  /** ◆ ArrayList 와 LinkedList 의 비교
   *
   * 배열의 경우 만약 index 가 n 인 원소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결된다.
   *
   * =================================================================
   * index 가 n 인 데이터의 주소값 = 배열의 주소 + n * 데이터 타입의 크기
   * =================================================================
   *
   * 0x100
   * Object[] arr = new Object[5];
   *
   * 위와 같이 Object 배열이 선언되었을 때, arr[2] 에 저장된 데이터 값을 읽으려 한다면 n 은 2, 모든 참조형 변수의 크기는 4byte 이고
   * 생성된 배열의 주소는 0x100 이므로 식은 다음과 같고
   *
   * 0x100 + 2 * 4byte
   *
   * 따라서 arr[2] 에 저장된 데이터의 주소값은 0x108 이다.
   * 배열은 각 데이터 요소들이 메모리상에 연속적으로 나열되어 있는 형태이기 떄문에 이처럼 간단한 계산만으로 원하는 데이터의 주소값을 얻어서
   * 데이터를 곧바로 읽어올 수 있지만, LinkedList 는 불연속적으로 위치한 요소들이 서로 연결된 것이라 어떠한 데이터를 찾으려면
   * 처음부터 n 번째 데이터까지 차례대로 따라가면서 찾아야 원하는 값을 얻을 수 있다.
   *
   * 그래서 LinkedList 는 저장된 데이터의 개수가 많을수록 데이터를 읽어오는 시간, 즉 접근시간(access time)이 길어진다는 단점이 있다.
   *
   * |      컬렉션           |   읽기(접근시간)     |    추가 또는 삭제  |         비고                                      |
   *  1.  ArrayList              빠름                   느림           순차적인 추가삭제는 빠름. 메모리 공간을 비효율적으로 사용.
   *  2. LikedList               느림                   빠름           데이터가 많을수록 읽기 속도가 더 느려짐
   *
   * 다루고자 하는 데이터의 개수가 변하지 않고 고정적이라면 ArrayList 가 좋은 선택이 되겠지만
   * 데이터의 개수가 변경이 잦다면 LinkedList 를 사용하는 것이 더 나은 선택이 될 것이다.
   *
   *
   *
   *
   * */

}
